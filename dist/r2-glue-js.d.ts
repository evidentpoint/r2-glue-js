// Generated by dts-bundle v0.7.3

export class EventHandling extends Client {
    readonly typeName: string;
    constructor(targetWindow: Window);
    addEventListener(target: string, eventType: string, properties: string[], listener: EventListener, options?: IAddEventListenerOptions): Promise<number>;
    removeEventListener(listenerID: number): void;
}

export class KeyHandling extends Client {
    readonly typeName: string;
    constructor(targetWindow: Window);
    addKeyEventListener(target: string, eventType: string, keyCode: string, listener: EventListener, options?: IAddKeyListenerOptions): Promise<number>;
    removeKeyEventListener(listenerID: number): void;
}

export class LinkHandling extends Client {
    readonly typeName: string;
    constructor(targetWindow: Window);
    addEventListener(target: string, eventType: string, properties: string[], listener: EventListener, options?: IAddEventListenerOptions): Promise<number>;
    removeEventListener(listenerID: number): void;
}

export class SelectionHandling extends Client {
    typeName: string;
    constructor(targetWindow: Window);
    addEventListener(target: string, listener: EventListener, options?: IAddEventListenerOptions): Promise<number>;
    removeEventListener(listenerID: number): void;
}

export class Highlighting extends Client {
    typeName: string;
    constructor(targetWindow: Window);
    createHighlight(rangeData: RangeData, options?: IHighlightOptions): Promise<void>;
}

export abstract class Client extends Receiver {
    abstract readonly typeName: string;
    protected constructor(namespace: string, targetWindow: Window);
    protected sendMessage(key: string, parameters: any[], callback?: MessageCallback): Promise<any> | void;
    protected processMessage(message: IMessage): void;
}

export enum EventHandlingMessage {
    AddEventListener = "ADD_EVENT_LISTENER",
    RemoveEventListener = "REMOVE_EVENT_LISTENER"
}
export interface IAddEventListenerOptions extends AddEventListenerOptions {
    preventDefault?: boolean;
    stopPropagation?: boolean;
    stopImmediatePropagation?: boolean;
}

export enum KeyHandlingMessage {
    AddKeyEventListener = "ADD_KEY_EVENT_LISTENER",
    RemoveKeyEventListener = "REMOVE_KEY_EVENT_LISTENER"
}
export type KeyEventType = 'keydown' | 'keypress' | 'keyup';
export interface IAddKeyListenerOptions extends IAddEventListenerOptions {
    once?: boolean;
    useCapture?: boolean;
}

export enum EventHandlingMessage {
    CreateHighlight = "CREATE_HIGHLIGHT"
}
export interface IHighlightOptions {
}

export interface RangeData {
    startOffset: number;
    startContainer: any[];
    endOffset: number;
    endContainer: any[];
}
export function createRangeData(range: Range): RangeData;
export function createRangeFromSelection(selection: Selection): Range;
export function createRangeFromRangeData(rangeData: RangeData): Range;

export type MessageCallback = (...params: any[]) => void;
export type MessageResponders = {
    [key: string]: (callback: MessageCallback, ...params: any[]) => Promise<any>;
};
export abstract class MessageHandler {
    abstract declarations: MessageResponders;
}

global {
    interface Window {
        glueEventMessageRemovers: any;
    }
}
export type sendMessage = (type: MessageType, name: string, parameters: any[]) => void;
export abstract class Receiver {
    protected constructor(namespace: string);
    destroy(): void;
    protected abstract processMessage(message: IMessage, sendMessage?: sendMessage): void;
}

export class Dispatcher extends Receiver {
    constructor(namespace: string, handlerType: {
        new (): MessageHandler;
    });
    protected processMessage(message: IMessage, sendMessage: sendMessage): void;
}

export enum MessageType {
    Invoke = "invoke",
    Return = "return",
    Callback = "callback"
}
export interface IMessage {
    readonly protocol?: string;
    readonly version?: string;
    readonly correlationId?: string;
    readonly namespace?: string;
    readonly type?: MessageType;
    readonly key: string;
    readonly value: any;
}
export class Message implements IMessage {
    readonly protocol: string;
    readonly version: string;
    readonly correlationId: string;
    readonly namespace: string;
    readonly type: MessageType;
    readonly key: string;
    readonly value: any;
    constructor(namespace: string, type: MessageType, key: string, value: any, correlationId?: string);
    static validate(message: IMessage): boolean;
}

